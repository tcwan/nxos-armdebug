<h1>Getting Started with NxOS-Armdebug (with Eclipse-Docker Build Environment)</h1>
<p>NxOS-Armdebug can be built and run on various OS, due to the use of Docker to manage the build process.
It has been tested on macOS Mojave (10.14.x) Big Sur (11.2.x), and will most likely work on other Linuxes.
It will probably work on recent Windows OS as well, but it has not been tested.</p>
<pre><code>For the Windows 10 platform, it is recommended to use the Windows Subsystem for Linux (WSL)
package which provides a propoer Linux (Ubuntu-based) user environment for working with NxOS-Armdebug.
</code></pre>
<h2>System Requirements</h2>
<ul>
<li>min dual-core x86 compatible CPU</li>
<li>min 8 GB RAM (needed to run Docker instance and Eclipse)</li>
<li>min 8 GB free HD space</li>
</ul>
<h2>Set up Tools</h2>
<ul>
<li>install <a href="https://www.docker.com/">Docker</a></li>
<li>install <a href="https://jdk.java.net/">JDK</a></li>
<li>install <a href="https://www.eclipse.org/cdt/">Eclipse CDT</a></li>
<li>install GDB Cross-Debugger (e.g. <code>arm-none-eabi-gdb</code>) from <a href="https://www.macports.org/">MacPorts</a> for macOS, or else some other source for your platform.</li>
</ul>
<pre><code>We will be running ARM Bare-metal applications on the NXT via NxOS-Armdebug. 
Make sure that the version of GNU compiler tools installed is configured as `arm-none-eabi-` versions.
`arm-linux-` or `arm-elf-` versions of the GNU compiler tools will not work.
</code></pre>
<h2>Install Docker Image</h2>
<p>This is best done via the terminal or shell.</p>
<ul>
<li>install arm-none-eabi docker image from <a href="https://hub.docker.com/r/tcwan/arm-none-eabi-gnutools">Docker Hub</a>
(This is based on the official ARM gcc tools release)</li>
</ul>
<pre><code>$ docker pull tcwan/arm-none-eabi-gnutools
</code></pre>
<ul>
<li>tag docker image by listing the available images to get the &lt;image_id&gt;</li>
</ul>
<pre><code>$ docker images
$ docker tag &lt;image_id&gt; arm-eabi
</code></pre>
<ul>
<li>run Docker image as a standalone interactive shell in Linux/macOS to verify proper installation (mapping current directory to /home)</li>
</ul>
<pre><code>$ docker run -it -v$PWD:/home --rm arm-eabi bash
[Inside Docker bash shell]
root@5c3ceeaae138:/work# ls /home
</code></pre>
<h2>Install Eclipse Plugins</h2>
<ul>
<li>Install Eclipse Docker Tooling from Eclipse Marketplace</li>
</ul>
<p>First open the Eclipse Marketplace Window in Eclipse CDT, then select Docker Tooling.</p>
<p><img src="images/Eclipse-Marketplace-Docker-Tooling.png" alt="Docker Tooling" /></p>
<p>After Installation, add Docker Explorer View by going to “Window-&gt;Show View-&gt;Other…”</p>
<p><img src="images/Eclipse-Add-View.png" alt="Add Docker Explorer View 1" /></p>
<p>Select Docker Explorer View, and place it in a perspective pane.</p>
<p><img src="images/Eclipse-Add-Docker-Explorer-View.png" alt="Add Docker Explorer View 2" /></p>
<h1>Obtaining NxOS-Armdebug Source Code</h1>
<p>First clone the NxOS-Armdebug project to the local hard drive.</p>
<pre><code>$ cd &lt;workspace dir&gt;
$ git clone https://github.com/tcwan/nxos-armdebug.git
</code></pre>
<p>This will create the NxOS-Armdebug folder as <code>nxos-armdebug</code> in the current directory.</p>
<h1>Building NxOS-Armdebug applications</h1>
<p>This can be done from the docker container bash shell prompt, or else you can define Build Targets in Eclipse and let Eclipse manage the build.</p>
<p>Note: Internally NxOS-Armdebug uses <code>scons</code> to build the actual project code. However, since we’re performing the build via Eclipse Docker integration, a top-level <code>Makefile</code> is used to dispatch the <code>scons</code> build inside the Docker container to enable smoother Eclipse-Docker integration.</p>
<h2>Building NxOS-Armdebug applications via command line</h2>
<p>It is possible to build NxOS-Armdebug using natively installed cross-compilation tools, but here we will use the pre-built Docker image for simplicity and consistency.</p>
<p>It is assumed that the Docker volume mounts have been setup properly, and you’re in the NxOS-Armdebug directory.</p>
<p>See <a href="https://linuxize.com/post/docker-run-command/">docker run</a> to understand how to setup the
volume parameter <code>-v</code>.</p>
<pre><code>$ cd &lt;nxos-armdebug dir&gt;
$ docker run -it -v$PWD:/home --rm arm-eabi bash

[Insider docker image]
# cd /home
/home#
</code></pre>
<ul>
<li>Build the application &lt;app_name&gt; (application folder should be located inside nxos/systems/)</li>
</ul>
<pre><code>/home# make &lt;app_name&gt;
</code></pre>
<ul>
<li>Example: build the application armskel located in nxos/systems/armskel</li>
</ul>
<pre><code>/home# make armskel
</code></pre>
<ul>
<li>Clean all generated code</li>
</ul>
<pre><code>/home# make clean
</code></pre>
<h2>Building NxOS-Armdebug applications via Eclipse</h2>
<h3>Importing NxOS-Armdebug into Eclipse workspace</h3>
<p>Make sure that NxOS-Armdebug project has been <a href="#obtaining-nxos-armdebug-source-code">cloned</a> to the local hard drive.</p>
<p>Then import it into Eclipse using “File-&gt;New-&gt;Project…”</p>
<p><img src="images/Eclipse-New-Project.png" alt="Eclipse New Project" /></p>
<p>and select “New Makefile Project with Existing Code”.</p>
<p><img src="images/Eclipse-Makefile-Project-from-Existing-Code.png" alt="Eclipse Makefile Project" /></p>
<h3>Setup NxOS-Armdebug to build with Docker</h3>
<p>To build NxOS-Armdebug applications using the Docker image, the Project setting must be updated.
Select the Project folder in the “Project Explorer”, then choose the “Project-&gt;Properties” menu item.</p>
<p>In the Project Properties dialog, select “C/C++ Build-&gt;Settings”, and click on the “Build Inside Docker Image” checkbox in the Container Settings tab (this should be visible if you’ve installed the Eclipse Docker Tooling plugin correctly). Don’t worry if you don’t see the “Toolchains” or “Devices” tab, these are used by the Eclipse Embedded/GNU MCU package, which is not needed for NxOS-Armdebug.</p>
<p>Type the correct image name, either <code>arm-eabi</code> if you have tagged the docker image, or else <code>tcwan/arm-none-eabi-gnutools</code> for the full image name.</p>
<p><img src="images/Eclipse-Docker-Build-Config.png" alt="Eclipse Docker Configuration" /></p>
<h3>Building the application</h3>
<p>By default Eclipse has a “Project-&gt;Build Project” menu item or a Build button which you can select. This will cause the project to perform a build if possible.</p>
<pre><code>Note: Eclipse's &quot;Project-&gt;Build Project&quot; menu will execute the last build command
(initially it is `make all`). However, if you've executed &quot;Project-&gt;Build Targets&quot;
subsequently, &quot;Project-&gt;Build Project&quot; will not work as expected.
</code></pre>
<p><code>make all</code> will cause <code>scons</code> to rebuild the last built application. If no applications were built previously it will build the libraries only.
However, it is not recommended to depend on <code>make all</code> for compiling NxOS-Armdebug applications since the outcome is not reliable.</p>
<p>If you select “Project-&gt;Clean…” (<code>make clean</code>) Eclipse will remove object code and generated output files.</p>
<h3>Defining Specific Build Targets</h3>
<p><img src="images/Eclipse-Create-Build-Targets.png" alt="Eclipse Build Targets" /></p>
<p>Eclipse provides a quick way to define specific build targets for a project. By right-clicking on the “Build Targets” item in the Project Explorer panel, you can access the “Create…” dialog to define build targets.</p>
<p>You should define build targets for specific applications instead of using the default target <code>all</code>. The name of the build target should be: <code>&lt;app_name&gt;</code>.
For example, to create a build target for the armskel project, just type <code>armskel</code> into the target name field.</p>
<h1>Running and Debugging NxOS-Armdebug application</h1>
<p><img src="images/Remote-GDB-Configuration.png" alt="Cross-Debugging" /></p>
<p>NxOS-Armdebug applications run on the NXT brick. This process is termed cross-debugging, since it involves executing a program compiled on the PC for a device using a different CPU architecture.
Cross-debugging for NXT involves the following steps:</p>
<ul>
<li>Establishing communications between the PC and the NXT brick via USB cable</li>
<li>Downloading applications (*.rxe) into the NXT brick using <code>nxtfilemgr</code></li>
<li>Configuring software debugging for the GDB server on the PC with the GDB stub on the NXT using <code>armnxtgdbserver</code></li>
<li>Configuring the Eclipse GDB Client (during initial debugging session)</li>
<li>Debugging the NXT applicaiton remotely</li>
</ul>
<h2>Downloading applications into the NXT brick</h2>
<p>It is assumed that the build process for the application has completed, and the <code>&lt;app&gt;.rxe</code> executable file has been generated successfully.</p>
<pre><code>Note: Several binary output files are created in the application project directory:
- &lt;app&gt;.rxe, which is the ARM bare-metal executable for downloading to the NXT brick and executed from RAM
- &lt;app&gt;_rxe.elf, which contains the debug symbols and object code used by the Eclipse debugger

You can ignore the other *.bin and *.elf output files as they're only needed if the application is flashed directly into the NXT Firmware 
(WARNING: Flashing the *.bin application into the NXT will erase the existing NXT firmware).
</code></pre>
<p>NXT File Manager (<code>nxtfilemgr</code>) is a X-Windows based application included with NxOS-Armdebug for downloading the application RXE file into the NXT RAM.
To run <code>nxtfilemgr</code>, you will need to have a X-server program on the PC. The Linux GUI Desktop has built-in X-server support. macOS requires the installation of the XQuartz X-server application.
There are X-servers available for Windows platform but it has not been tested with <code>nxtfilemgr</code>.</p>
<pre><code>$ cd &lt;nxos-armdebug dir&gt;
$ scripts/nxtfilemgr
</code></pre>
<p><img src="images/NXT-File-Manager.png" alt="NXT File Manager" /></p>
<p>From the NXT File Manager application, you can use the “Add” button to select the <code>*.rxe</code> file to be downloaded to the NXT.
Please note that the NXT expects contiguous free space to be available for the file to be downloaded.
If the application states that there is insufficient free space available, you should first select an existing file, and then
press the “Remove” button to delete it, in order to free up contiguous space needed for the new file.</p>
<p>Make sure that the NxOS-Armdebug application is running (“Execute”) since the GDB server can only connect to a running NXT application. The GDB server cannot launch any NXT applications remotely.</p>
<h2>Configuring Software Debugging for the GDB Server on the PC</h2>
<p>Each NxOS-Armdebug application is embedded with a GDB Stub module during the build. When the <code>*.rxe</code> application is executed on the NXT, the GDB stub will wait to receive GDB debugging commands via the USB connection.
The GDB Stub implements the GDB serial debugging protocol on top of the USB bus since the NXT does not come with a default serial port. In order to communicate with the GDB Stub module on the NXT, a GDB server is needed to interface between the GDB Clients and the USB connection.</p>
<p>After making sure that the NXT application is running, the GDB Server <code>armnxtgdbserver</code> can then be started.
<code>armnxtgdbserver</code> converts GDB serial protocol commands sent via the TCP-based GDB client connections into USB messages needed by the GDB Stub on the NXT and vice-versa.</p>
<p>The GDB Server program is best run in a terminal window via the command line.</p>
<pre><code>$ cd &lt;nxos-armdebug dir&gt;
$ scripts/armnxtgdbserver -v

### `-v` is verbose output to help in debugging the GDB Server program

</code></pre>
<p>In the terminal window, follow the directions given until the prompt:</p>
<pre><code>Waiting for GDB connection on port 2828...
</code></pre>
<p>is displayed. This means that the GDB Server is now ready to accept connections from the GDB Client process.</p>
<p><img src="images/ARMNXTGDBServer-Trace.png" alt="ARM NXT GDB Server" /></p>
<h2>Configuring the Eclipse GDB Client</h2>
<p>The Eclipse IDE has a built-in GDB Client which provides source level cross-platform debugging capabilities.</p>
<p>First, create a new Debug Launch Configuration via the Run Menu “Debug Configurations…” menu item.</p>
<p><img src="images/Eclipse-Menu-Debug-Configurations.png" alt="Eclipse Debug Configuration" /></p>
<p>Then, in the Dialog, double-click on the “C/C++ Remote Applicaiton” item in the left panel.</p>
<p><img src="images/Eclipse-Debug-Configuration-Dialog.png" alt="Eclipse Debug Dialog" /></p>
<p>This will create a new Debug Launch Configuration entry, with the corresponding configuration dialog.</p>
<p>Make sure that the Name of the Launch Configuration reflects the application to be debugged.
In addition, the C/C++ Application field <em>MUST</em> point to the <code>&lt;app&gt;_rxe.elf</code> file for the application.</p>
<p><img src="images/Eclipse-DebugConfig-Main.png" alt="Eclipse Debug Main Tab" /></p>
<p>Then, the GDB Remote Debugging Launcher must be changed by clicking on “Select Other…” at the bottom of the dialog.
First, check the “Use Configuration Specific Setting” checkbox, then select the “GDB (DSF) Manual Remote Debugging Launcher” item.</p>
<p><img src="images/Eclipse-DebugConfig-Main-Launcher.png" alt="Eclipse Debug Manual Launcher" /></p>
<p>After clicking on “Ok”, it will return to the main configuration dialog. We will then configure the “Debugger” tab next.
Change the initial breakpoint given by “Stop on Startup at:” to <code>break</code>.</p>
<p><img src="images/Eclipse-DebugConfig-Main-Debugger.png" alt="Eclipse Debug Debugger Tab" /></p>
<p>The “Debugger” tab has three sub-tabs. In the “Main” subtab, we need to configure the “GDB Debugger” field to the full path for the cross-platform GDB client which can understand ARM bare-metal executable files.
Generally, this is named <code>arm-none-eabi-gdb</code> in MacPorts, as well as most Linux distributions.</p>
<pre><code>Generic GDB with multiarch support (which needs to be enabled during tool installation) can be used
but it will need to have the executable target type configured correctly via the command prompt or .gdbinit. 

It is easier to install the `arm-none-eabi-` version instead since everything is pre-configured.
</code></pre>
<p><img src="images/Eclipse-DebugConfig-Main-Debugger-Connection.png" alt="Eclipse Debug Connection" /></p>
<p>Finally, in the “Connection” subtab, the port should be changed to <code>2828</code>.</p>
<p>After all the changes have been made, click “Apply” and “Close” the dialog to save the settings.</p>
<h2>Debugging the NXT application remotely</h2>
<p><em>Note: Make sure that the NXT application has been <a href="#downloading-applications-into-the-nxt-brick">downloaded and running</a>, and GDBServer is <a href="#configuring-software-debugging-for-the-gdb-server-on-the-pc">running</a> before invoking the Eclipse Debug Perspective on the PC.</em></p>
<p>After the configuration of the Debug Launch Configuration, launch it, and switch over to the Eclipse Debug Perspective.</p>
<p>Eclipse will display the Debugging window, with the  the process panel and source listing for the main applicaiton.
Initially, the program will be shown in a running state, since the NXT Debugger will not respond until a command is issued from within the GDB Debugger screen.
Pause the execution of the NXT application using the <code>Pause</code> (double vertical bar) button.</p>
<p><img src="images/Eclipse-GDB-Initial-Debug.png" alt="Debug Perspective" /></p>
<p>The Debug Perspective will then show which routine the program is currently stopped in, the variables and breakpoints inspection panel, a listing of the current line in the source file, and the console information for GDB.</p>
<p><img src="images/Eclipse-GDB-Remote-Debug.png" alt="Debug Pause" /></p>
<p>Since the template NxOS-Armdebug program has defined a breakpoint at the label <code>break</code>, it should indicate that the application exeuction has stopped at that breakpoint.
In this case, it stopped after executing the instruction at the breakpoint.</p>
<p>The contents of variables and CPU registers can be inspected via the Reister pane. For the NXT, only the CPSR/SPSR and General Purpose Registers (<code>R0-R15</code>) are valid.
The Floating-point registers are not found in the ARMv4T CPU used in the NXT and will show dummy content.</p>
<p>If the Register pane is not visible, add it via the “Window” menu, “Show View”, “Registers” menu item.
The pane can be move to the appropriate window group for easy reference (typically in the same window as the “Variables” pane).
Since GDB is primarily a C-based debugger, the variables will not show relevant information for ARM Assembly programs.</p>
<p><img src="images/Eclipse-Debug-Register-Enable.png" alt="Enabling Register Pane" /></p>
<p>When <code>Single Step</code> is pressed, the ARM CPU will execute the next instruction, pause, and display the updated register contents with highlighting.</p>
<p><img src="images/Eclipse-GDB-Remote-Debug-Stepin.png" alt="Step-In Subroutine" /></p>
<h2>Setting Breakpoints</h2>
<p>The GDB Debugger allows single-stepping and continue. <code>Single-Stepping</code> will execute one instruction at a time on the ARM CPU.
<code>Continue</code> will resume execution of the program without pausing until the next breakpoint is encountered.</p>
<p>To set a breakpoint, double-click on the line number column. This will set a <code>breakpoint</code> which is indicated by a blue dot.</p>
<p><img src="images/Eclipse-GDB-Remote-Debug-Breakpoint.png" alt="Setting Breakpoints" /></p>
<p>After stopping at a breakpoint, pressing <code>Continue</code> will single-step past the current instruction and stop. This is because the Debugger stub needs to update the instruction memory with the original instruction at the previous breakpoint. The Second press of <code>Continue</code> will continue execution without stopping.</p>
<pre><code>WARNING: Single stepping and breakpoints should not be used inside Interrupt Service Routines 
(Exception Routines) since ARMDebug uses software instructions to implement breakpoints. 

Interrupts are disabled inside Interrupt Service Routines, and ARMDebug would not receive the 
necessary interrupt from the USB bus to exchange data with the PC.
</code></pre>
